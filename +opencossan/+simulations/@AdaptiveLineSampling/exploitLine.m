function [Xobj,Tline,XpartialSimOut,Xsamples] = exploitLine(Xobj,Xtarget,varargin)
% EXPLOIT LINE
% Locate the point on the limit state for a simulated direction, starting
% from any point in the space, and collect all relevant information
% regarding the line.

% See also: https://cossan.co.uk/wiki/index.php/@AdaptiveLineSampling
%
% Author:~Marco~de~Angelis
% Institute for Risk and Uncertainty, University of Liverpool, UK
%% Validate input arguments
OpenCossan.validateCossanInputs(varargin{:});

% % Initialise vector to store performance values
% VgStore=NaN(1,Xobj.NmaxPoints);
% % Initialise vector to store line distances
% VdStore=NaN(1,Xobj.NmaxPoints);
% % Initialise vector to store line's point norm
% VnStore=NaN(1,Xobj.NmaxPoints);

% initialise variables
Valpha=Xobj.VdirectionSNS;
VinitialDistance=0;
iLine=0;
lineIndex=0;
for k=1:2:length(varargin)
    switch (lower(varargin{k}))
        case 'reliabilityindex'
            mostProbablePointNorm = varargin{k+1};
        case 'valpha'
            Valpha = varargin{k+1};
        case {'vhyperplanepoint'}
            % Coordiantes of the point where the line originates from. In 
            % LineSampling it lies on the orthogonal hyperplane to the 
            % important direction.In AdvancedLineSampling the line does 
            % not originate from this point, but still it is a mandatory 
            % point for the  method construction.
            VhyperPlanePoint = varargin{k+1};
        case {'vinitialdistance','startingdistance'}
            % This is the distance of the first evaluation point from the
            % orthogonal hyper plane.
            VinitialDistance = varargin{k+1};
        case {'linenumber','line'}
            % Current line
            iLine = varargin{k+1};
        case 'lineindex'
            % Current line index
            lineIndex = varargin{k+1};
        otherwise
            % error, unknown property specified
            error('OpenCossan:AdaptiveLineSampling:exploitLine',...
                ['Field name (' varargin{k} ') not allowed']);
    end
end

% Make sure the important direction is a unit column vector
Valpha=Valpha(:)/norm(Valpha);

% % keep the original important direction
% Valpha0=Valpha;

% % Make sure reliabilityIndex is not empty
% if isempty(Xobj.reliabilityIndex)
%     reliabilityIndex=NaN;
% else
%     reliabilityIndex=Xobj.reliabilityIndex;
% end

% Make sure VlineHyperPlanePoint is a column vector
VhyperPlanePoint=VhyperPlanePoint(:);


% Evaluate points coordinates. The number of columns of this matrix-array
% must be equal to the number of random variables.
MlinePoints=transpose(repmat(VhyperPlanePoint,1,length(VinitialDistance))+...
    Valpha*VinitialDistance);


% Perform Line Search
    [stateFlag,mostProbablePointNormNew,distanceLimitState,VgLine,VlineDistances,...
        Valpha,ValphaNew,VstatePoint,LdirectionalUpdate,XpartialSimOut,Xsamples]...
        =...
        lineSearch(Xobj,...
        'Xtarget',Xtarget,...
        'reliabilityIndex',mostProbablePointNorm,...
        'VinitialDistance',VinitialDistance,...
        'VhyperplanePoint',VhyperPlanePoint,...
        'Valpha',Valpha,...
        'MlinePoints',MlinePoints,...
        'iLine',iLine,...
        'Salgorithm','NewtonRaphson');
    
%% Write results of the analysis on text files

% % store line's results by adding a row in the following matrix
% VlineResults=[iLine,...
%     lineIndex,...
%     distanceLimitState,...
%     reliabilityIndex,...
%     LdirectionalUpdate,...
%     stateFlag,...
%     Xobj.ibatch];

% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% % Write line results on a text file
% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% fid = fopen(fullfile(Xobj.StempPath,'mlineresults.txt'), 'a');
% fprintf(fid, '\n %i %i %g %g %i %i %i', VlineResults);
% fclose(fid);
% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% % write one line on a text file to descirbe what's on mlineresults.txt
% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% if iLine == 0
%     SlineInfo='line number,  line index,  hyperplane-boundary distance,  directional update,  state flag,  batch number';
%     fid = fopen(fullfile(Xobj.StempPath,'mlineresultsinfo.txt'), 'a');
%     fprintf(fid, SlineInfo);
%     fclose(fid);
% elseif iLine==1
%     SlineInfo='line number,  line index,  hyperplane-boundary distance,  directional update,  state flag,  batch number';
%     fid = fopen(fullfile(Xobj.StempPath,'mlineresultsinfo.txt'), 'a');
%     fprintf(fid, SlineInfo);
%     fclose(fid);
% end
% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


% collect results from the current line 
Tline=struct('iLine',iLine,'lineIndex',lineIndex,...
    'distanceLimitState',distanceLimitState,...
    'reliabilityIndex',mostProbablePointNorm,...
    'LdirectionalUpdate',LdirectionalUpdate,...
    'stateFlag',stateFlag,'iBatch',Xobj.ibatch);


% % specify here the precision for storing results in the text file 
% SstringFormat=Xobj.makeString4TextFile('%1.12e',length(VgStore));

% iend=length(VgLine);

% % store performance values
% VgStore(1:iend)=VgLine;
% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% % Write performance values on a text file
% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% fid = fopen(fullfile(Xobj.StempPath,'mperformancevalues.txt'), 'a');
% fprintf(fid, SstringFormat, VgStore(:)');
% fclose(fid);
% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Tline.Vg=VgLine;

% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% % Write line distances on a text file
% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% VdStore(1:iend)=VlineDistances;
% % store values in a text file
% fid = fopen(fullfile(Xobj.StempPath,'mlinedistances.txt'), 'a');
% fprintf(fid, SstringFormat, VdStore(:)');
% fclose(fid);
% %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Tline.Vdistances=VlineDistances;

% VnStore(1:iend)=V;

SstringFormat=Xobj.makeString4TextFile('%1.12e',length(VhyperPlanePoint));

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% Write hyperplane coordinates on a text file
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
fid = fopen([Xobj.StempPath,filesep,'MhyperPlaneCoords.txt'], 'a');
fprintf(fid, SstringFormat, VhyperPlanePoint(:)');
fclose(fid);
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Tline.VhyperPlanePoint=VhyperPlanePoint;

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% Write limit state coordinates on a text file
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
fid = fopen([Xobj.StempPath,filesep,'MlimitStateCoords.txt'], 'a');
fprintf(fid, SstringFormat, VstatePoint(:)');
fclose(fid);
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Tline.VstatePoint=VstatePoint;

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% Write important direction coordinates on a text file
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
fid = fopen([Xobj.StempPath,filesep,'MimportantDirections.txt'], 'a');
fprintf(fid, SstringFormat, ValphaNew(:)');
fclose(fid);
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Tline.Valpha=Valpha;
Tline.ValphaNew=ValphaNew;
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% write coordinates of the last important direction on text
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
fid = fopen([Xobj.StempPath,filesep,'VlastImportantDirection.txt'], 'w');
fprintf(fid, SstringFormat, ValphaNew(:)');
fclose(fid);
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Tline.mostProbablePointNorm=mostProbablePointNorm;
Tline.mostProbablePointNormNew=mostProbablePointNormNew;

end